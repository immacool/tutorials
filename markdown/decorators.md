
# Введение в дектораторы в Python 3.x

## Что такое декоратор?

Декоратор - это функция, которая принимает другую функцию и расширяет ее функциональность без явного изменения исходного кода функции.

Вот наипростейший пример декоратора:

```py
def my_decorator(func):
    def wrapper():
        print("Что-то делаем до вызова функции.")
        func()
        print("Что-то делаем после вызова функции.")
    return wrapper
```

Объявим простую функцию и применим к ней декоратор:

```py
def say_whee():
    print("Юху!")

say_whee = my_decorator(say_whee)

say_whee()
```

Вывод:

```py
Что-то делаем до вызова функции.
Юху!
Что-то делаем после вызова функции.
```

Теперь обсудим, что же тут произошло. Мы создали функцию `my_decorator`, которая принимает функцию `func` в качестве аргумента[^1] и возвращает функцию `wrapper`. Функция `wrapper` в свою очередь вызывает функцию `func` и расширяет ее функциональность. В нашем случае мы просто выводим сообщения до и после вызова функции `func`.
Вложенная функция `wrapper` принимает те же аргументы, что и функция `func`, т.к. вместо `func`, мы на самом деле вызываем `wrapper` внутри `my_decorator`. В нашем случае функция `func` не принимает аргументов, поэтому и `wrapper` не принимает никаких аргументов.

Теперь давайте перепишем функцию `say_whee` в более лаконичном виде:

```py
@my_decorator
def say_whee():
    print("Юху!")

say_whee()
```

Вывод:

```txt
Что-то делаем до вызова функции.
Юху!
Что-то делаем после вызова функции.
```

Как видите, результат работы программы не изменился. Но теперь код выглядит намного проще. `@my_decorator` - это синтаксический сахар, который позволяет нам избежать явного вызова `my_decorator` и передачи ей функции `say_whee` в качестве аргумента.

## Декораторы с аргументами

Декораторы могут принимать аргументы. Например, давайте напишем декоратор, который будет принимать аргумент `func_info` и выводить его вместе с сообщением, а так же добавим параметр `verbose` для включения/отключения вывода сообщения со значением по умолчанию `True`:

```py
def my_decorator(func_info, verbose=True):
    def decorator(func):
        def wrapper():
            if verbose:
                print("Что-то делаем до вызова функции.")
            func()
            if verbose:
                print("Что-то делаем после вызова функции.")
            print(f"Информация о функции: {func_info}")
        return wrapper
    return decorator
```

Теперь давайте применим этот декоратор к функции `say_whee`:

```py
@my_decorator("Это функция say_whee")
def say_whee():
    print("Юху!")

say_whee()
```

Вывод:

```txt
Что-то делаем до вызова функции.
Юху!
Что-то делаем после вызова функции.
Информация о функции: Это функция say_whee
```

Первая функция `my_decorator` принимает аргументы `func_info` и `verbose` для дальнеейшего использования во вложенной функции `decorator`. Вторая функция `decorator` принимает функцию `func`, функционал которой мы собираемся расширить. Третья функция `wrapper` принимает аргументы, которые передаются в декорируемую функцию `say_whee`. Внутри функции `wrapper` мы вызываем декорируемую функцию `say_whee`, а так же выводим сообщение и информацию о функции.

А для того, чтобы, например, создать декоратор, который сможет работать с любыми функциями[^2], нам необходимо использовать `*args` и `**kwargs`, для позиционных и именованных аргументов соответственно:

```py
def my_decorator(func):
    def wrapper(*args, **kwargs):
        print("Что-то делаем до вызова функции.")
        func(*args, **kwargs)
        print("Что-то делаем после вызова функции.")
    return wrapper
```

Таким образом, мы можем декорировать любые функции, которые принимают аргументы:

```py
@my_decorator
def equclidian_distance(x1, y1, x2, y2):
    return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5

print(equclidian_distance(0, 0, 3, 4))
```

Вывод:

```txt
Что-то делаем до вызова функции.
5.0
Что-то делаем после вызова функции.
```

## Декораторы классов и методов

### Декораторы классов

Декораторы классов работают аналогично декораторам функций, за исключением того, что они декорируют классы. Декораторы классов могут быть полезны, когда вы хотите расширить функционал класса динамически, не изменяя его исходный код.

Для примера создадим класс `Car`:

```py
class Car:
    def __init__(self, model, color):
        self.model = model
        self.color = color

    def __str__(self):
        return f"Машина {self.model} цвета {self.color}"
```

Теперь создадим декоратор, который будет добавлять к классу новый метод `drive`:

```py
def add_drive_method(cls):
    def drive(self):
        print(f"{self.model} поехала!")
    cls.drive = drive
    return cls
```

Теперь декорируем класс `Car`:

```py
@add_drive_method
class Car:
    def __init__(self, model, color):
        self.model = model
        self.color = color

    def __str__(self):
        return f"Машина {self.model} цвета {self.color}"
```

Теперь мы можем создавать экземпляры класса `Car` и вызывать у них метод `drive`:

```py
car = Car("Toyota", "red")
print(car)
car.drive()
```

Вывод:

```txt
Машина Toyota цвета red
Toyota поехала!
```

### Декораторы методов

Декораторы методов отличаются лишь тем, что теперь мы декорируем методы класса, а не сам класс. Для примера создадим класс `Car`:

```py
class Car:
    def __init__(self, model, color):
        self.model = model
        self.color = color

    def __str__(self):
        return f"Машина {self.model} цвета {self.color}"
```

Теперь создадим декоратор, который будет добавлять к методу класса новый метод `drive`:

```py
def add_drive_method(func):
    def drive(self):
        print(f"{self.model} поехала!")
        return func(self)
    return drive
```

Теперь декорируем метод `__str__`:

```py
class Car:
    def __init__(self, model, color):
        self.model = model
        self.color = color

    @add_drive_method
    def __str__(self):
        return f"Машина {self.model} цвета {self.color}"
```

Теперь, когда мы вызываем метод `__str__`, он будет так же вызывать функцию `drive`:

```py
car = Car("Toyota", "red")
print(car)
```

Вывод:

```txt
Toyota поехала!
Машина Toyota цвета red
```

Разберемся, что происходит в коде выше. Когда мы декорируем метод `__str__`, мы создаем новую функцию `drive`, которая вызывает метод `__str__`, передавая в аргуент объект класса, и затем выводит сообщение `Toyota поехала!`. Таким образом, мы можем расширять функционал методов класса динамически, так же не изменяя исходный код класса.

## Декораторы функций в виде классов

В качестве альтернативы декораторам в виде функций можно использовать декораторы в виде классов. Для примера создадим функцию, которая будет выводить сообщение:

```py
def say_hello():
    print("Hello!")
```

Теперь создадим декоратор в виде класса:

```py
class Decorator:
    def __init__(self, func):
        self.func = func

    def __call__(self):
        print("До вызова функции")
        self.func()
        print("После вызова функции")
```

Теперь декорируем функцию `say_hello`:

```py
@Decorator
def say_hello():
    print("Hello!")
```

Теперь, когда мы вызываем функцию `say_hello`, она будет вызывать декоратор, который будет выводить сообщения до и после вызова функции:

```py
say_hello()
```

Вывод:

```txt
До вызова функции
Hello!
После вызова функции
```

В классе `Decorator` мы создаем метод `__init__`, который принимает в качестве аргумента функцию, которую мы хотим декорировать. Затем мы сохраняем эту функцию в атрибуте `func`. Теперь, когда мы вызываем функцию `say_hello`, мы на самом деле вызываем метод `__call__`[^3] класса `Decorator`. В этом методе мы выводим сообщение до вызова функции, затем вызываем функцию, которую мы декорировали, и выводим сообщение после.

[^1]: В Python функции являются объектами первого класса, поэтому мы можем передавать их в качестве аргументов другим функциям.
[^2]: Учитывая тот факт, что `wrapper` принимает аргументы переданной функции `func`, перед тем, как передать их ей самой.
[^3]: `__call__` - магический метод, который вызывается, когда мы вызываем объект класса через `()`.
