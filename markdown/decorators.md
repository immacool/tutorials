
# Введение в дектораторы в Python 3.x

## Что такое декоратор?

Декоратор - это функция, которая принимает другую функцию и расширяет ее функциональность без явного изменения исходного кода функции.

Вот наипростейший пример декоратора:

```py
def my_decorator(func):
    def wrapper():
        print("Что-то делаем до вызова функции.")
        func()
        print("Что-то делаем после вызова функции.")
    return wrapper
```

Объявим простую функцию и применим к ней декоратор:

```py
def say_whee():
    print("Юху!")

say_whee = my_decorator(say_whee)

say_whee()
```

Вывод:

```py
Что-то делаем до вызова функции.
Юху!
Что-то делаем после вызова функции.
```

Теперь обсудим, что же тут произошло. Мы создали функцию `my_decorator`, которая принимает функцию `func` в качестве аргумента[^1] и возвращает функцию `wrapper`. Функция `wrapper` в свою очередь вызывает функцию `func` и расширяет ее функциональность. В нашем случае мы просто выводим сообщения до и после вызова функции `func`.
Вложенная функция `wrapper` принимает те же аргументы, что и функция `func`, т.к. вместо `func`, мы на самом деле вызываем `wrapper` внутри `my_decorator`. В нашем случае функция `func` не принимает аргументов, поэтому и `wrapper` не принимает никаких аргументов.

```py

Теперь давайте перепишем функцию `say_whee` в более лаконичном виде:

```py
@my_decorator
def say_whee():
    print("Юху!")

say_whee()
```

Вывод:

```py
Что-то делаем до вызова функции.
Юху!
Что-то делаем после вызова функции.
```

Как видите, результат работы программы не изменился. Но теперь код выглядит намного проще. `@my_decorator` - это синтаксический сахар, который позволяет нам избежать явного вызова `my_decorator` и передачи ей функции `say_whee` в качестве аргумента.

## Декораторы с аргументами

Декораторы могут принимать аргументы. Например, давайте напишем декоратор, который будет принимать аргумент `func_info` и выводить его вместе с сообщением, а так же добавим параметр `verbose` для включения/отключения вывода сообщения со значением по умолчанию `True`:

```py
def my_decorator(func_info, verbose=True):
    def decorator(func):
        def wrapper():
            if verbose:
                print("Что-то делаем до вызова функции.")
            func()
            if verbose:
                print("Что-то делаем после вызова функции.")
            print(f"Информация о функции: {func_info}")
        return wrapper
    return decorator
```

Теперь давайте применим этот декоратор к функции `say_whee`:

```py
@my_decorator("Это функция say_whee")
def say_whee():
    print("Юху!")

say_whee()
```

Вывод:

```py
Что-то делаем до вызова функции.
Юху!
Что-то делаем после вызова функции.
Информация о функции: Это функция say_whee
```

Первая функция `my_decorator` принимает аргументы `func_info` и `verbose` для дальнеейшего использования во вложенной функции `decorator`. Вторая функция `decorator` принимает функцию `func`, функционал которой мы собираемся расширить. Третья функция `wrapper` принимает аргументы, которые передаются в декорируемую функцию `say_whee`. Внутри функции `wrapper` мы вызываем декорируемую функцию `say_whee`, а так же выводим сообщение и информацию о функции.

А для того, чтобы, например, создать декоратор, который сможет работать с любыми функциями[^2], нам необходимо использовать `*args` и `**kwargs`, для позиционных и именованных аргументов соответственно:

```py
def my_decorator(func):
    def wrapper(*args, **kwargs):
        print("Что-то делаем до вызова функции.")
        func(*args, **kwargs)
        print("Что-то делаем после вызова функции.")
    return wrapper
```

Таким образом, мы можем декорировать любые функции, которые принимают аргументы:

```py
@my_decorator
def equclidian_distance(x1, y1, x2, y2):
    return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5

print(equclidian_distance(0, 0, 3, 4))
```

Вывод:

```py
Что-то делаем до вызова функции.
5.0
Что-то делаем после вызова функции.
```

## Декораторы классов и методов

### Декораторы классов

Декораторы классов работают аналогично декораторам функций, за исключением того, что они декорируют классы. Декораторы классов могут быть полезны, когда вы хотите расширить функционал класса динамически, не изменяя его исходный код.

Для примера создадим класс `Car`:

```py
class Car:
    def __init__(self, model, color):
        self.model = model
        self.color = color

    def __str__(self):
        return f"Машина {self.model} цвета {self.color}"
```

Теперь создадим декоратор, который будет добавлять к классу новый метод `drive`:

```py
def add_drive_method(cls):
    def drive(self):
        print(f"{self.model} поехала!")
    cls.drive = drive
    return cls
```

Теперь декорируем класс `Car`:

```py
@add_drive_method
class Car:
    def __init__(self, model, color):
        self.model = model
        self.color = color

    def __str__(self):
        return f"Машина {self.model} цвета {self.color}"
```

Теперь мы можем создавать экземпляры класса `Car` и вызывать у них метод `drive`:

```py
car = Car("Toyota", "red")
print(car)
car.drive()
```

Вывод:

```py
Машина Toyota цвета red
Toyota поехала!
```

### Декораторы методов

Декораторы методов отличаются лишь тем, что теперь мы декорируем методы класса, а не сам класс. Для примера создадим класс `Car`:

```py
class Car:
    def __init__(self, model, color):
        self.model = model
        self.color = color

    def __str__(self):
        return f"Машина {self.model} цвета {self.color}"
```

Теперь создадим декоратор, который будет добавлять к методу класса новый метод `drive`:

```py
def add_drive_method(func):
    def drive(self):
        print(f"{self.model} поехала!")
        return func(self)
    return drive
```

Теперь декорируем метод `__str__`:

```py
class Car:
    def __init__(self, model, color):
        self.model = model
        self.color = color

    @add_drive_method
    def __str__(self):
        return f"Машина {self.model} цвета {self.color}"
```

Теперь, когда мы вызываем метод `__str__`, он будет так же вызывать функцию `drive`:

```py
car = Car("Toyota", "red")
print(car)
```

Вывод:

```py
Toyota поехала!
Машина Toyota цвета red
```

[^1]: В Python функции являются объектами первого класса, поэтому мы можем передавать их в качестве аргументов другим функциям.
[^2]: Учитывая тот факт, что `wrapper` принимает аргументы переданной функции `func`, перед тем, как передать их ей самой.
